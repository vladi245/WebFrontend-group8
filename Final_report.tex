\documentclass[12pt]{article}


% PACKAGES

\usepackage[margin=2.5cm]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{array}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{float}
\usepackage{placeins}
\graphicspath{{./graphs/}}

% HEADER & FOOTER
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{[GetStanding]}
\fancyhead[R]{Semester Project 3 - 2025}
\fancyfoot[C]{\thepage}

\begin{document}


% TITLE PAGE CONTENT 


\begin{center}
    \begin{center}
    {\Large \textbf{Semester Project 3 - 2025}}\\[2cm]

    {\Huge \textbf{GetStanding}}\\[0.5em]
    {\Large Smart Desk Control System}\\[1em]

    {\large Semester Project: Distributed Software Systems with Embeded Elements (E25)}\\[0.5em]
    {\large (SE3-PRO Internal Course Code/T630011401 Course ID)}\\[0.5em]
    {\large University of Southern Denmark, The Faculty of Engineering, Sønderborg Campus}\\[0.5em]
    {\large Semester 3, September - December 2025}\\[0.5em]
    {\large BSc in Engineering (Software Engineering) - Sønderborg}\\[1.5em]

    {\Large \textbf{Group 8}}\\[1cm]
\end{center}

    \textbf{Authors:}\\[0.5cm]
Piotr Szczesny – piszc24@student.sdu.dk \\
Vlad-Alexandru Ionita - vlion24@student.sdu.dk \\ 
Karolina Malik - kamal24@student.sdu.dk \\ 
Bartosz Bobkiewicz - babob24@student.sdu.dk \\ 
Viktor Barabás - vibar24@student.sdu.dk \\ 
Azra Talum - aztal24@student.sdu.dk\\[0.5cm]

    \textbf{Supervisor:} \\[0.5em]
    Aleksandra Kril - alkri23@student.sdu.dk
\end{center}



% SHORT HISTORY

\section*{Short History}
Adjustable desks have become an important part of modern workplaces by reducing the negative effects of sitting too long and increasing the general health and productivity of employees. Many design trends have changed the office environment over the years but recently integrating smart technologies such as IoT have become more popular. By connecting IoT technology with a smart desk, user can enjoy the convenience of pushing a button to achieve better ergonomics, health, and well-being while working at their desk. The project, in collaboration with LINAK focuses on making the workspace smarter, healtier, and more productive. 

% ABSTRACT

\section*{Abstract}
In office environment, while spending most of the days in front of a computer and a desk people tend to forget about crucial breaks for their health. GetStanding addresses the growing need for healthier work environments by integrating reliable technology into adjustable desk systems provided by LINAK. 
The application allows users to input their body height which used to calculate recommended sitting and standing desk height. Another key feature is ability to control and monitor a adjustable desk by communicating with the desk API. 
It is done by connecting to the API attached to the desk and sending the HTTP requests to modify the position of the desk. The project was created a using modern tech stack, with a React based frontend, while the backend was implemented using Node.js and includes the integration of a Raspberry Pi Pico board as an external edge gateway.

\newpage


% TABLE OF CONTENTS

\tableofcontents
\newpage


% CHAPTERS FROM TEMPLATE


\section{Introduction}
GetStanding is a web based application developed as part of a university course project, based on cases provided by LINAK. It addresses the challenge of maintaining a healthy lifestyle, while working in an office environment.

\subsection{Motivation}
Prolonged sitting can harm both wellbeing and productivity, yet people often forget to stand, stretch, or take short breaks throughout the day. Additionally, the lack of integration between work routines and fitness apps makes it difficult to accurately track and assess physical activity, limiting the ability to maintain a healthy, active lifestyle.

\subsection{Objective}
The team's objective is to help people keep track of their habits. The way we do this is through GetStanding, an application that presents user given data in a clear, easy to understand, and intuitive format. Habits like workouts, time spent standing, and meals get tracked on graphs on a weekly basis.  Having the options for a user to select their own height and based on that, through an algorithm, GetStanding gives a recommended standing and sitting height. One of the most important objective for us was to get this done through one application. GetStanding, unlike other fitness tracking applications, also has the capability to connect to a sit and stand desk, to track the user's time spent standing or sitting. Another goal was to make a way for users to keep track of each other through a friends activity feature. This would ensure that a user would return to GetStanding on regular basis. And lastly, getting rewarded for keeping good habits, such as spending a certain amount of time standing, is also a good incentive. 

\subsection{Delimitation}
The problems encoured by the team during the project were mainly related to the time limitations. Initially the group wanted to add additional features, such as a friends page and rewards, but have decided that we do not have the time capacity to implement them. The team had to prioritize certain tasks within the system that needed more attention and were more important when it comes to the better outcome of the product. As for the application itself, the application requires user to keeping track of their workouts, water and food consumption. In this case, when the data is inconsistent or missing, visualizations and the graphs may not accurately show user's improvement over time.
\newpage



\section{Methodology}

\subsection{Development Process and Collaboration}
The team based on combined experience from previous projects and other courses, has decided to follow an Agile methodology during the development of GetStanding.
\\\\
The development process was split into two-week sprints, with Jira used as a tool for organization and keeping all team members on track. To ensure smooth development, each sprint had clear objectives that were decided during sprint planning meetings. Throughout those sessions, the backlog was populated with work items, which were assigned to adequate epics and split between team members.\\
During those two weeks the team combined online communication with in-person meetings, which frequency varied based on current needs. \\
After each sprint finished, sprint review sessions were held. During those meetings the team could reflect on the progress that was made. They were essential for understanding how much workload is realistic to complete in the span of two weeks, which was crucial for improving upcoming development and avoiding setting unrealistic expectations.\\\\
In practice the process of developing GetStanding was iterative. Starting from early sprints that focused on establishing the base structure of the web application, and ending with later sprints that focused on adding additional features and refinements. Moreover, feedback was not limited to formal meetings. Frequent informal conversations, short check-ins, group coding sessions were an integral part of how the project was carried out. This approach made solving encountered issues easier, as it was an opportunity to share knowledge, exchange ideas, and decide on how to move forward together.\\
By combining this gradual way of delivering the application with continuous internal feedback, as well as receiving guidance from the supervisor, and finally demo presentations for LINAK and the project coordinator, the team was able to improve both GetStanding and work practices. 
\subsection{Technology Stack}

\subsubsection{Frontend}
For developing the frontend the team used React with Vite. Keeping the web application consistent across different pages was of great importance, therefore React, which is characterized by its component-based approach aligned with the teams vision. It made creating reusable user interface components possible, which made the development process easier by keeping the code clearer, easier to maintain and avoiding code repetition. Choosing Vite enabled the team to work in  a fast development environment with it's live development server, which provides feedback once the changes happen.\\
Prior to writing any code, a design was vital, thus Figma was the starting point of every UI element. The process of designing took place inside a shared workspace, making it able for each team member to stay updated with each others' progress and potentially inspire new ideas within the team.
\subsubsection{Backend}
The backend was implemented using Node.js with Express.js. This set up was selected due to its simplicity and suitability for developing RESTful APIs. Additionally it is well-established in the field, offers a broad set of libraries and comes with wide community-support.

\subsubsection{Data Storage and Infrastructure}
As the database management system, PostgreSQL is chosen due to being known for its reliability, flexibility, and support for relational data types. This allowed the safe storage and scaling of data using SQL skills gained through the Data Management course.\\\\
For containerization purposes the team used Docker. It helped with keeping the environment consistent across different devices and reduced configuration problems. Most of the members had previous experience with mentioned tools, therefore reusing them was a logical choice, that allowed the team members to refine their skills with this popular development tool.\\\\
One of the core requirements for this project was the integration of a Raspberry Pi Pico W board. The team was introduced to it during the Programming for Hardware Constrained Environments course, thus its use in the project provided an opportunity to apply the concepts learned there.

\subsection{Version Control}
Git and GitHub were the tools used throughout the whole development of GetStanding. To keep the codebase stable, work was carried out in separate branches rather than the main branch. In order to make the review process more manageable the team tried to stick to suitable and clear naming habits, that includes branches, commits, pull requests. Each pull request was reviewed by at least one other member and comments were left if necessary. Also, the reviewing focused not only on whether the code was working, but also examined it from a maintainability and readability perspective.\\
Collaborating this way and mutual support improved the team's spirit and contributed to the growth as developers.\\\\
Overall, the selected way of working, tools, and technologies, combined with the experience from previous semesters and the new knowledge acquired this term, is what made designing and implementing GetStanding possible.


\newpage

\section{Problem Analysis - LOOK AT THIS }
Many studies have demonstrated that prolonged sedentary behavior increases health risks such as obesity, cardiovascular diseases as well as
decreased productivity. Also back pain, shoulder stiffness, lower back pain, and mental health issues have also been noted as common reasons for decreased work performance. \\\\
A study stated that people who predominantly sit at work have a 16 higher risk of mortality from all causes, and a 34\% higher risk of mortality from cardiovascular disease To counteract the increased risk, individuals who sit a lot at work would have to engage in an additional 15 to 30 minutes of physical activity per day to reduce their risk to that of individuals who do not predominantly sit, researchers estimated.\\\\
This project serves as a preventive health solution, aiming to encourage the users to adopt healthier habits during their workday. GetStanding aims to track and monitor the duration of sitting and provide their standing habit insights over time. By seeing their weekly performance and tracking progress, users stay motivated and consistent.

\subsection{Key Challenges}
The most important challenge with this project is to get the user to follow up on their daily statistics on standing as well as to make changes to their daily behavior by providing encouragement. The process of developing new habits is based on the amount of time and effort it takes to develop new habits therefore, many users may ignore the daily stats if they are too busy or if they lack the motivation. This may decrease the effectiveness of the proposed solution. \\\\
There are technical challenges in this project related to synchronizing data in real-time from the desk sensor, the user application, and the database. Synchronization delays or connectivity issues may prevent tracking stats from being sent, and thus decrease the overall effectiveness of the system. Addressing these challenges strategically will ensure that GetStanding effectively promotes a healthier and more productive workspace environment.

\section{Requirements}
This section represents the functional and non-functional requirements of the GetStanding application. Functional requirements describe the core requirements that the application must respect, while non-functional requirements focus on the performance, security and usability of the application, rather than what it is supposed to do. This set of requirements guides the development of the application to guarantee that it meets user needs.

\subsection{MoSCoW}
\subsection{Must Have}
\begin{itemize}
    \item User can log in to their own account.
    \item User can sign up and create a new account.
    \item User can remove their account and information from the app.
    \item User can connect the platform to the desk.
    \item User can control the desk height from the interface.
    \item User can log out from their account.
    \item User cannot access the screens of the app when logged out.
    \item App must have multiple user types.
\end{itemize}
\subsection{Should Have}
\begin{itemize}
    \item Endpoints secured from unauthorized access.
    \item User can change their name.
    \item User can add and log their meals and workouts.
    \item User can see their own standing stats.
\end{itemize}
\subsection{Could Have}
\begin{itemize}
    \item User could add friends and see their feed.
    \item User could receive email notifications about their progress.
    \item App could be hosted on a VPS.
    \item User could change their email and password.
\end{itemize}
\subsection{Won't Have}
\begin{itemize}
    \item App won't have a reward system.
    \item App won't accept payments.
    \item App won't have a newsletter.
\end{itemize}

\subsection*{Functional Requirements}
\begin{itemize}
	\item Users shall be able to sign up and log in to the application.
	\item Users shall be able to update their profile information, including username and height.
	\item The UI shall allow input and editing of user data.
	\item The system shall store and retrieve user information and desk preferrence data in a database.
	\item The system shall log desk usage data, including sitting and standing durations.
	\item The application should provide the user with data regarding their sitting time using graphs.
	\item The system shall be able to control the desk’s height via the WIFI2BLE Box Web API.
	\item The system shall retrieve and display the current desk height and position.
	 \item Users shall be able to customize their desk settings, such as preferred standing and sitting heights.
\end{itemize}

\subsection*{Non-Functional Requirements}

\begin{itemize}
    \item The system shall support multiple users.
    \item User data shall be protected with secure authentication.
    \item The app shall be compatible with major modern browsers.
    \item The system shall provide clear, user-friendly error messages (in plain English).
\end{itemize}




\section{Design}
This section outlines the design of GetStanding application, outlining the process of creating a software that fullfils the project requirements. This phase involved team efforts focused on defining system behaviour through scenarios and use cases, establishing user-interface design via prototyping and establishing the architecture and  timeline through diffrent diagrams. Taking those steps has established a well-documented foundation for implementation and development of the system. \\\\

\subsection{Scenarios}

\paragraph{Scenario A: Adjusting desk height}

\begin{description}
    \item[\textbf{Actor:}] Logged-in user
    \item[\textbf{Goal:}] Change the desk height to a comfortable level.
    \item[\textbf{Context:}] User is on the Desk Details page.
\end{description}

\textbf{Main Flow:}
\begin{enumerate}
    \item The user opens the Desk Details page.
    \item The system displays the current desk height.
    \item The user drags the slider up or down to change the desk height.
    \item The displayed numeric height updates in real time.
    \item The desk moves accordingly to match the selected slider position.
\end{enumerate}

\paragraph{Scenario B: Setting Sitting and Standing Preferences}

\begin{description}
    \item[\textbf{Actor:}] Logged-in user
    \item[\textbf{Goal:}] Configure preferred sitting and standing desk heights manually.
    \item[\textbf{Context:}] The user is on the Desk Details page and wants to customize their position settings.
\end{description}

\textbf{Main Flow:}
\begin{enumerate}
    \item The user uses the toggle switch to select either "Sitting" or "Standing" mode.
    \item Under "Preferred Sitting Height (cm) – Manual" or "Preferred Standing Height (cm) – Manual", 
          the user presses the " + " or " - " buttons to adjust the numeric height value.
    \item The system updates the displayed value with each button press.
    \item The user clicks "Confirm" to save their new height setting.
    \item A confirmation message is displayed to indicate successful saving.
    \item The system stores the preferred sitting or standing height in the database.
\end{enumerate}

\paragraph{Scenario 3: Desk Connection }

\begin{description}
    \item[\textbf{Actor:}] Logged-in user
    \item[\textbf{Goal:}] Understand why the desk cannot be controlled and receive clear feedback.
    \item[\textbf{Context:}] The Desk Details page is open, but the system shows a red "Disconnected" status banner.
\end{description}

\textbf{Main Flow:}
\begin{enumerate}
    \item The user opens the Desk Details page.
    \item The system attempts to connect to the desk simulator but fails.
    \item A red banner appears displaying "Disconnected".
    \item The user checks their network or simulator connection and refreshes the page. 
    \item The system reconnects successfully, and displays a green "Connected" banner.
\end{enumerate}

\subsection*{Use Cases}
\subsubsection*{UC1 - Create Account}

\textbf{Goal:} Allow a new user to create their personal account.\\
\textbf{Primary actor:} New user\\
\textbf{Preconditions:}
\begin{itemize}
    \item The email address is not already in use.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item A new account is created and stored in the system.
    \item The user can log in with the new credentials.
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The user navigates to the web app sign-up page.
    \item The user enters the required information (name, email, password) and accepts the terms and conditions.
    \item The system validates the input.
    \item The system creates a new account.
    \item The system redirects the user to the login page.
\end{enumerate}


\subsubsection*{UC2 - Log In}

\textbf{Goal:} Allow a user to access their personal smart desk settings and data.\\
\textbf{Primary actor:} User\\
\textbf{Preconditions:}
\begin{itemize}
    \item The user has an account.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item The user is authenticated.
    \item The user sees their dashboard.
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The user navigates to the web app login page.
    \item The user enters their email and password.
    \item The system validates the credentials.
    \item The system logs the user in and shows the dashboard.
\end{enumerate}


\subsubsection*{UC3 - Adjust Desk Height from Web App}

\textbf{Goal:} Let the user set the current height of the desk via the web interface.\\
\textbf{Primary actor:} User\\
\textbf{Preconditions:}
\begin{itemize}
    \item The user is logged in.
    \item A desk is connected to the system.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item The desk has moved to the requested height (or is in the process of moving).
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The user opens the desk control page.
    \item The user chooses a target height.
    \item The system sends the height command to the desk.
    \item The system shows the updated height/state.
\end{enumerate}


\subsubsection*{UC4 - Get Recommended Desk Heights}

\textbf{Goal:} Allow the user to enter their body height so the system can calculate and display recommended desk heights for both sitting and standing.\\
\textbf{Primary actor:} User\\
\textbf{Preconditions:}
\begin{itemize}
    \item The user is logged in.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item The user’s body height is stored in their profile.
    \item Recommended sitting and standing desk heights are calculated and shown to the user.
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The user opens the Settings page in the web app.
    \item The user enters their body height.
    \item The system validates the input (checks if it is within a realistic range).
    \item The system calculates recommended sitting and standing desk heights based on the entered body height.
    \item The system displays the recommended heights to the user on the desk page.
    \item The system stores the body height in the user’s profile.
\end{enumerate}


\subsubsection*{UC5 - View Weekly Standing Statistics}

\textbf{Goal:} Allow the user to see their weekly standing statistics in a graphical form on the dashboard.\\
\textbf{Primary actor:} User\\
\textbf{Preconditions:}
\begin{itemize}
    \item The user is logged in.
    \item Standing/sitting usage data has been recorded for the user.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item The user has seen a visual overview of their standing time for the current week.
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The user opens the dashboard page.
    \item The system retrieves the user’s standing/sitting data for the current week.
    \item The system displays a graph showing the weekly standing statistics.
    \item The user reviews the graph to understand their standing behaviour for the current week.
\end{enumerate}


\subsubsection*{UC6 - Manage User Accounts}

\textbf{Goal:} Allow an admin to view user accounts and manage their access by changing account type or deleting accounts.\\
\textbf{Primary actor:} Admin\\
\textbf{Preconditions:}
\begin{itemize}
    \item The admin is logged in with admin rights.
    \item Users exist in the system.
\end{itemize}
\textbf{Postconditions:}
\begin{itemize}
    \item User accounts may remain unchanged, be updated (account type), or be removed, depending on the admin’s actions.
\end{itemize}

\textbf{Main flow:}
\begin{enumerate}
    \item The admin navigates to the admin dashboard page.
    \item The system displays a list of users (name, email, account type) with available actions for each user:
    \begin{itemize}
        \item Change account type
        \item Delete account
    \end{itemize}
    \item The admin searches for or filters users if needed.
    \item The admin locates the relevant user in the list.
    \item The admin chooses one of the actions for that user:
    \begin{enumerate}
        \item[5a.] \textbf{Change account type}\\
              The admin clicks the Change account type action for the selected user.\\
              The admin selects a new account type (standard/premium).\\
              The system updates the account type.
        \item[5b.] \textbf{Delete account}\\
              The admin clicks the Delete account action for the selected user.\\
              The system asks for confirmation.\\
              The admin confirms and the system deletes the account.
    \end{enumerate}
    \item The system updates the user list to reflect the changes.
\end{enumerate}

\subsection{Prototyping}
The development of the frontend involved a two-phase prototyping process. During the initial phase, team members created prototypes using Figma within a three day period. Following that deadline, the team reviewed them and selected the favored design while identifying desirable elements from the alternative prototypes. These preferred elements were then integrated into the chosen design. Throughout the development process, minor details of the design were updateded and refined to align with project objectives.\\\\ 

\begin{figure} [H]
	\centering
	\includegraphics[width=0.32\textwidth]{prototype}
	\hfill
	\includegraphics[width=0.32\textwidth]{bartekdesign}
	\hfill
	\includegraphics[width=0.32\textwidth]{piotrdesign}
	\caption{Initial proposed prototypes}
\end{figure}
\subsection{Diagrams}
\subsubsection{Sequence Diagram}
The sequence diagram provides a illustration of the system's flow and the interaction between its core modules. It details the process of adjusting the height of the desk. The proccess initiates when the application loads the desk page. Upon accomplishing a connection with the physical desk or the simulator, user actions such as dragging the height slider or setting their specific height preference trigger a request. This request is delivered to the backend which subsequently communicates with the desk or simulator using the dedicated Pico Gateway. This process results in the physical update of the desk's height to the value specified by the user.\\\\

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{sequence-1}\\
	\includegraphics[width=0.7\textwidth]{sequence-2}\\
	\includegraphics[width=0.7\textwidth]{sequence-3}
\end{figure}
\subsubsection{Flowchart Diagram}
The flowchart visually represents the process of user loging in and  the subsequent flow within the GetStanding Dashboard. The user's journey begins at the home page. If the user is new to the application then they are first required to register an account before procceding to log in, while existing users navigate directly to log in process. Upon succesful authentication the system directs the user to the appropriate dashboard either Premium or Standard based on their assigned account type. \\\\

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{flowchart}
\end{figure}
\subsubsection{Deployment Chart - LOOK AT THIS}
Following the university's project structure, the team went through 3 key stages. Starting with Project Kickoff, during which the team was introduced to the semester project topic and general requirements. Followed by Project Analysis, where the concept of GetStanding was established. This phase also included, outlining core functionalities, identifying the requirements and defining key objectives. The implementation, combined with iterative improvements and refinements was carried out in the final, Project Development stage.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{deployment}\\
Deployment Chart of GetStanding
\end{figure}

\subsubsection{DB design - LOOK AT THIS}
Prior to implementation, the team introduced a database design to define its structure. It served as a guiding reference during the development stage by clearly specifying main entities and their relationships. \\
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{db-design}\\
	Database design graph
\end{figure}
\subsubsection{Technology and Infrastructure - LOOK AT THIS}
Backend operates using Express.js witj Node.js, and connects with a PostgreSQL database running in Docker,  As for the frontend, it is developed using React and Vite. Additionally, GetStanding includes two gateways: one included within the provided desk simulator, and a second gateway developed by the team using the PicoBoard.\\
All frontend requests are processed by the backend. Depending on the request, the backend either retrieves data from the database and returns it to the frontend, or forwards updated desk-state information to the gateway. The gateway then communicates the change to the desk and updates its state accordingly.\\
\begin{figure}[H] 
	\centering 
	\includegraphics[width=0.7\textwidth]{uml}\\
	Technology and Infrastructure of GetStanding
\end{figure}
\newpage

\section{Implementation}
The implementation of GetStanding was structured to ensure modularity, scalability, and maintainability. The project was divided into four key elements: the frontend, the backend, the database and the gateway bridge setup.\\\\
The frontend and backend were developed hand in hand to ensure compatibility and a shared vision across the team. The database is built as a relational system, keeping all data organised, consistent, and easy to manage. The gateway setup adds an extra layer of security by clearly separating the external app logic from the internal day-to-day operations used within companies. This structure ensures reliability, security, and smooth functionality for both end users, GetStanding administrators and IT departments.

\subsection{Frontend}
The frontend for GetStanding is built with React Vite, resulting in a modular, component-based architecture. This approach made it easy to implement new ideas and quickly pivot by discarding features when necessary. Additionally, Vite’s development server with live refresh significantly improved the developer experience, allowing changes to be reflected instantly without needing to restart the application. On top of that use of Docker in later stages of the project made sure that all deployments were working on the correct versions of packages, and most importantly Node.js. \\\\
The project is split into pages stored in the folder pages/ and components stored in the folder components/. The decision for this setup was to make a new page and component creation easier, where pages function as a “component of components” connected to a specific route.

\subsubsection{Routing - src/App.tsx}
Routing is handled using the react-router-dom package, with all routes managed in the App.tsx file. As mentioned earlier, this approach made it easier for the team to add new pages and routes. Additionally, it simplified the setup of a custom /404 page, ensuring lost users are redirected appropriately and do not get lost navigating the app.\\\\
Centralizing routing enabled the team to implement a ProtectedRoute component, which manages client-side access control for dashboard subpages. Each route wrapped with ProtectedRoute is accessible only after a user logs in. Furthermore, this component supports a requiredType property, allowing specification of the account type necessary to access certain pages. For example, only an admin can read messages from the contact form, while features such as Meals are available exclusively to premium users of GetStanding.

\subsubsection{services/api.ts}
During development, the team recognized the need to centralize API calls. Previously, API requests were scattered across pages and components, leading to inconsistencies, especially when system ports were occupied on different operating systems. To address this, the team created a single entry point for all API connections in services/api.ts. This file stores the backend server address, making it easier to update API endpoints and ensuring that the JWT token (stored in local storage) is automatically included with every request made from the frontend.

\subsubsection{Styling - .module.css files}
The team opted not to use CSS frameworks like Tailwind. Instead, they chose to use separate CSS files for each component and page. To avoid conflicts and maintain flexibility, CSS Modules were employed. This approach allows for repeating class names across components without unintended overrides, ensuring a clean and maintainable styling system.

\subsection{Backend}
The backend was designed around the MVC (Model-View-Controller) architecture and a RESTful API. The team initially focused on developing the frontend with mock data to better understand the system’s requirements before diving into complex business logic. 

\subsubsection{Routes}
Similar to the frontend, the backend centralises route management in the app.js file. However, instead of defining routes directly, it imports them from separate files in the routes/ folder (e.g., routes/desk.js, routes/adminRoutes.js). This modular approach improves code clarity and maintainability, especially given the backend’s higher number of routes compared to the frontend. 

\subsubsection{Models}
In the MVC architecture, Models handle the core business logic and database interactions. They define functions to query the PostgreSQL database, ensuring data integrity and consistency.

\subsubsection{Controllers}
Controllers act as the intermediary between the View (frontend) and the Models. They handle user input, perform validation (checking if a user exists), and manage the flow of data between the frontend and backend.

\subsubsection{Authorisation - JWT}
User authorisation is managed using JWT (JSON Web Tokens) and permissions are set based on users account type. Upon login, users receive a JWT token with an expiration time of 1 hour. This token is included in every API request to the backend, where it is validated and correct data is sent back. Requests without a valid token are automatically rejected, ensuring secure access to the system.\\\\
The token is checked using src/middleware/authMiddleware.js and imported into every API endpoint as authMiddleware.

\subsubsection{Authentication}
User authentication is handled in controllers/authController.js. The login method verifies credentials by checking the submitted email against the database and comparing the submitted password hash with the stored hashed password. If both match, the user is authenticated and granted access to the GetStanding app.
The register method follows a similar principle but focuses on creating a new user account instead of validating an existing one.

\subsection{Database}
The database for GetStanding was designed as a relational database, leveraging PostgreSQL for its robustness, scalability, and flexibility over JSON document based approaches. To ensure consistency across development, testing, and production environments, the database was containerized using Docker, simplifying deployment and reducing environment-specific issues. This setup allowed the team to maintain a structured and normalized schema, optimizing data integrity and minimizing redundancy when it comes to tables.

\subsubsection{Functions}
To ensure scalability and future-proofing, the team implemented PostgreSQL functions as a core part of the database architecture. These functions are designed to encapsulate specific business logic and are called directly from the backend models. This approach not only modularizes database operations but also enhances security by allowing granular control over access permissions. Instead of granting users broad access to entire tables, the team can now restrict permissions to individual functions, minimizing the risk of unauthorized data manipulation or exposure.\\\\
During development, this strategy provided greater control and flexibility. By abstracting complex queries and operations into reusable functions, the team reduced redundancy, improved code maintainability, and streamlined debugging. Additionally, it allowed for consistent data handling, as all interactions with the database are funneled through these predefined functions, ensuring compliance to business rules and reducing the likelihood of errors. This design ensures that the system can easily accommodate future extensions, such as adding new features or integrating third-party services, without requiring significant refactoring or altering the access levels in the database (creating 
database users).

\subsection{Network Security}
The system architecture intentionally employs a dual-gateway design consisting of an external (semi-trusted) gateway and an internal (trusted) gateway. This approach was selected to set clear trust boundaries between externally accessible components and internal business-critical systems. By separating these responsibilities, the architecture reduces the risk of a single point of compromise affecting the entire system and supports a defence-in-depth security strategy.\\\\
The two gateways serve distinct roles and operate in different security contexts:

\begin{itemize}
	\item Raspberry Pi Pico acts as the External Edge Gateway, interfacing with the GetStanding application.
	\item Wifi2ble functions as the Internal Device Gateway, handling communication with smart desks within the office network.
\end{itemize}

\subsubsection{External Edge Gateway - Raspberry Pi Pico}
The Raspberry Pi Pico was selected to handle communication between the GetStanding application, operating on an external network, and the internal system. Its role is deliberately limited to enforcing a minimal and controlled connection to the outside world. The gateway physically and logically restricts access by exposing only a narrowly defined interface and allowing only predefined data to be forwarded to internal endpoints for further validation.\\\\
The Pico gateway reads desk height adjustment requests exclusively from a single trusted source: the backend of the GetStanding application. By limiting data intake to this specific endpoint, the system reduces exposure to external threats such as DNS hijacking or API abuse. Even in the event that the application backend is compromised, the gateway ensures that only constrained and expected data can traverse into the internal network.\\\\
This design choice was made to reduce the blast radius of potential attacks originating from external actors. Should the Pico gateway become unavailable due to overload or a targeted attack, internal desk functionality inside the workplace remains unaffected. Employees retain the ability to operate and adjust desks locally without reliance on the external application. The team identified that the GetStanding application is an optional productivity feature, not a mission-critical component, and therefore, its failure must not disrupt the core business operations.

\subsubsection{Internal Device Gateway - Wifi2ble Desk API}
The Wifi2ble gateway operates as the internal device gateway responsible for communication with the smart desks over Wi-Fi and BLE protocols. This component is provided and maintained by the desk manufacturer and was not modified as part of this project.\\\\
Because the wifi2ble gateway resides entirely within the trusted internal network, it is intentionally not exposed to the external environment. Restriction of outside access is enforced at the network and router level, ensuring that only pre-approved internal traffic can reach the device gateway. This separation allows the system to leverage manufacturer-provided functionality while maintaining internal network isolation and security.

\section{Validation and testing}
This chapter outlines what type of testing was used to ensure GetStanding's stability, functionality, and positive user experience. It also explains how each type of testing contributed to the final product.

\subsection{Unit Testing}
Unit Testing is used to verify whether individual pieces of code, mainly functions and methods, work correctly when isolated, so without depending on any external systems. Ideally, unit testing should be a continuous part of the development process to fully benefit from it, as it makes finding bugs easier and in general saves time when searching for which part of the existing code broke after adding changes. For future projects, mentioned benefits will be kept in mind from the start, rather than introducing it in later stages of the development, as it was in this case.\\\\
In GetStanding, the backend is covered by a set of unit tests, that were executed with the use of Jest, which is a JavaScript testing framework. The database layer is mocked, therefore the testing can focus on the web application logic and validation rules. From a more detailed perspective, the test ensure that data is read and written in a consistent way, for example when changing desk height or storing desk usage records for later statistics, Additionally, they verify that creating, updating and deleting entities behave as expected. Moreover, they also test if validation rules act appropriately when they are given invalid input.\\\\
This combination of functional and validation-focused unit tests strengthens the entire backend. Despite late implementation, unit testing proved to be valuable. It gave the team more confidence and stability regarding the web application's core logic, as well as enhanced the overall quality of GetStanding.

\subsection{Integration Testing}
Integration tests were used in order to validate how different parts of the system work together. This means that realistic HTTP requests were sent to the backend API to check how routing, controllers, validation and authentication worked together. The testing mainly covered typical scenarios, such as registering and logging in, updating user-related data, as well as performing admin actions. Again, the database layer was mocked so that the API could be tested without depending on a specific database setup. It also helped with verifying if the system responded with appropriate status codes and messages for both expected/normal and error situations.

\subsection{Manual Testing}
Manual testing was carried out to ensure that GetStanding functions properly from
a user experience angle. It was an ongoing part of the development process and was carried out regularly throughout the project, whenever new features were implemented or code was merged. This practice helped with identifying edge cases, visual inconsistencies or UI/UX problems that may not have been caught by automated testing. Additionally, observing whether graphs and statistics were updating correctly was rather relevant, since GetStanding is a tracking web application after all. Overall, manual tests contributed to a smoother and more reliable user experience.


\subsection{Test Results and Analysis}
This section summarizes the outcome of carried out tests. Detailed test cases and their individual outcomes are listed in the Appendix.
\subsubsection*{Unit Tests}
All unit tests passed successfully, ensuring the functionality of individual units.
\subsubsection*{Integration Tests}
All integration tests passed, ensuring end-to-end API functionality, specifically:
\begin{itemize}
    \item authentication and authorization
    \item  correct HTTP status codes 
    \item protected route enforcement
\end{itemize}
\subsubsection*{Manual Tests}
Manual testing revealed:
\begin{itemize}
    \item Inconsistent layout across different devices (phones, tablets)
\end{itemize}

\subsubsection*{Highlights}
\begin{itemize}
    \item 100\% backend test completion rate 
\end{itemize}

\subsection{Conclusion}
Testing is crucial for delivering a reliable and quality product, which was the vision for GetStanding. By combining unit and integration tests with manual testing, the team was able to make sure that GetStanding's core functionality works as intended and that it offers an intuitive and positive user experience.

\newpage

\section{Conclusion}
GetStanding was developed as a semester project in collaboration with LINAK, based on the scenarios given by them at the start of the sememster. The team chose to make an application to help people, with a focus on office workers, keep track of their habits. Despite some changes from the original plan for the application, the main functions were successfully implemented such as tracking of calorie intake, workouts and water consumption. The most important feature is that GetStanding can connect to a sit and stand desk, helping the user keep track of the time they spend standing throughout the day. While there were challanges throughout the developmet proces, such as delays that ended up affecting the teams progression. The communication inside the team was informal. For some of the team members this was the first time working with multiple repositories and embedded elements like the Pico board, which added to the level of difficulty. 


\subsection{Summary}
Overall, it can be said that the outcome of the project was a success. GetStanding has provided us with valuable experince both in technical and teamwork scenarios. This will be a good foundation to build on in the future.

\subsection{Future Improvements}
The team has designed GetStanding with extensibility in mind, ensuring the application can easily allow for future enhancements. For example, the friends system, initially planned but canceled due to time constraints, could be revisited and implemented. Another key improvement could involve enhancing database security by securing individual PostgreSQL functions (which were already implemented with this goal in mind) instead of relying on a single database account.

In terms of teamwork and workflow, the team made significant progress in communication and workload distribution compared to the previous semester. However, there is still room for improvement in punctuality and setting and realising deadlines. Additionally, following to consistent commit and branch naming conventions would further streamline version control and collaboration.

\newpage


% REFERENCES

\section*{References}
There are no sources in the current document.

Follow IEEE citation format as described in the template.
\begin{thebibliography}{9}

\bibitem{lamport94}
  Leslie Lamport,
  \emph{\LaTeX: A Document Preparation System}.
  Addison Wesley, Massachusetts,
  2nd Edition,
  1994.


\end{thebibliography}

\newpage


% APPENDIX

\section*{Appendix A}
[Supplementary content, raw data, code snippets, logs, manuals, etc.]

\end{document}